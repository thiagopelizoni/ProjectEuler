# Problem: https://projecteuler.net/problem=382
def mat_mul(A, B, m):
    r = len(A)
    c = len(B[0])
    k = len(B)
    res = [[0] * c for _ in range(r)]
    for i in range(r):
        for j in range(c):
            for p in range(k):
                res[i][j] = (res[i][j] + A[i][p] * B[p][j]) % m
    return res

def mat_pow(M, exp, m):
    size = len(M)
    res = [[1 if i == j else 0 for j in range(size)] for i in range(size)]
    while exp > 0:
        if exp % 2 == 1:
            res = mat_mul(res, M, m)
        M = mat_mul(M, M, m)
        exp //= 2
    return res

def mat_vec_mul(A, v, m):
    r = len(A)
    res = [0] * r
    for i in range(r):
        for j in range(len(v)):
            res[i] = (res[i] + A[i][j] * v[j]) % m
    return res

def main():
    """
    Purpose
    -------
    Computes the last 9 digits of f(10^18), where f(n) is the number of subsets of U_n that
    generate at least one polygon.

    Method / Math Rationale
    ------------------------
    The sequence s_n is generated by the recurrence s_n = s_{n-1} + s_{n-3} for n > 3, with
    s_1=1, s_2=2, s_3=3. U_n = {s_1, ..., s_n}. A subset generates a polygon if it has at least
    3 elements and the sum of the elements is greater than twice the maximum element.
    This is equivalent to f(n) = 2^n - 4 - sum_{j=2}^{n-1} h(j), where h(k) is the number of
    subsets of U_k with sum <= s_{k+1}. h(k) satisfies the linear recurrence
    h(k) = 3 h(k-1) - 2 h(k-2) + 2 h(k-3) - 5 h(k-4) + h(k-5) + h(k-6) + 3 h(k-7) - 2 h(k-8)
    for k >= 9. The sum of h(j) is computed using matrix exponentiation on an augmented state
    vector modulo 10^9.

    Complexity
    ----------
    O(9^3 log(10^18)) ~ O(729 * 60) operations, which is negligible.

    References
    ----------
    https://projecteuler.net/problem=382
    """

    mod = 1000000000
    n = 10**18
    exp = n - 9
    size = 9
    coeff = [3, -2, 2, -5, 1, 1, 3, -2]
    M = [[0] * size for _ in range(size)]
    M[0][0] = 1
    for i in range(8):
        M[0][i + 1] = coeff[i] % mod
    for i in range(8):
        M[1][i + 1] = coeff[i] % mod
    for i in range(1, size - 1):
        M[i + 1][i] = 1
    V = [272, 128, 67, 36, 20, 11, 6, 4, 2]
    Mp = mat_pow(M, exp, mod)
    Vf = mat_vec_mul(Mp, V, mod)
    S = Vf[0]
    pow2 = pow(2, n, mod)
    ans = (pow2 - 4 - S) % mod
    print(ans)

if __name__ == "__main__":
    main()